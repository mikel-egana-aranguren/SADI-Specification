<!DOCTYPE html>
<html>
  <head>
    <title>Semantic Automated Discovery and Integration</title>
    <meta charset='utf-8'/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "Member-SUBM",
          shortName:  "SADI",
          previousMaturity: "FPWD",
          previousPublishDate:  "2016-1-25",
          logos: [
               {
                  src: "http://sadiframework.org/content/wp-content/themes/SADI/images/sadi-header.png",
                  href: "http://sadiframework.org",
                  alt: "SADI - Semantic Automated Discovery and Integration",
                  width: 300,
                  id: 'SADILogo'
               }
            ],
         
          editors: [
                {   name:       "Mark Wilkinson",
                    url:        "http://wilkinsonlab.info/",
                    company:    "CBGP-UPM",
                    companyURL: "http://www.cbgp.upm.es/" },
                {   name:       "Michel Dumontier",
                    url:        "http://semanticscience.org/",
                    company:    "Stanford University",
                    companyURL: "http://www.stanford.edu/"},
                {   name:       "Luke McCarthy",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Benjamin Vandervalk (original author)",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Chris Baker",
                    url:        "",
                    company: "University of New Brunswick",
                    companyURL: "http://www.unb.ca/"
                },
                {   name:       "Alexander Ryazanov",
                    url:        "",
                },
          ],
          wg:           "HCLS",
          wgURI:        "https://www.w3.org/blog/hcls/",
          wgPublicList: "",
          wgPatentURI:  "",
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes Semantic Automated Discovery and Integration
   (SADI), a set of best practices for implementing stateless web
   services that consume RDF data as input and generate RDF data as
   output.  The goal of SADI is to establish conventions that will
   enable a much higher level of interoperability between web services
   from independent providers than is currently possible under the
   widespread use of WSDL/XML and RESTful services.  Under SADI,
   interoperability depends on the shared use of predicate vocabularies,
   rather than the shared use of particular XML schemas, JSON
   structures, or ad hoc data formats.  Through the use of OWL to
   describe service input and output datatypes, SADI enables: i)
   automated discovery of services that provide data or computations of
   interest, and ii) automated matchmaking between local data and
   available services.  By iterative application of the former two
   capabilities, SADI enables semi-automated construction of arbitrarily
   complex workflows across independent service providers.
      </p>
    </section>

    <section id='sotd'>
      <p>
 </p>
    </section>
    
    <section class='informative'>
      <h2>Executive Summary</h2>
      <p>
SADI is a set of best practices for implementing stateless web
   services that natively consume RDF data as input and generate RDF
   data as output.  Its primary purpose is to increase the
   interoperability of services across independent providers.  Under
   SADI, the schemas for the input and output RDF data of a service are
   defined by the service's _input OWL class_ and _output OWL class_,
   respectively.  Provider-specified metadata about a service, including
   the URIs of the input and output OWL classes, is published as an RDF
   document that is retrievable by an HTTP GET on the service URL.
   Service invocation is accomplished by issuing an HTTP POST request to
   the service URL with an appropriate input RDF document as the request
   body.  The input RDF document contains one or more instances of the
   input OWL class which represent independent inputs to the service,
   and in response the service returns an output RDF document with a
   corresponding number of instances of the output OWL class.  Each
   output instance has the same root URI as its corresponding input
   instance, in order to ensure that the data consumed and generated by
   the service are explicitly linked.
    </section>
    <section class='conformance'>
      <h2>Conformance</h2>
      As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

The key words MUST, MUST NOT, REQUIRED,SHOULD,SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this specification are to be interpreted as described in [[RFC2119]].

    </section>
    <section>
        <h2>Introduction</h2>

The principal benefit of web services is that they enable widespread
   and convenient reuse of software components, independent of the
   larger applications or goals being realized by the client software.
   However, in the current climate of WSDL/XML [[WSDL]] and RESTful
   services [[REST]], the successful implementation of web service clients
   still depends on detailed human knowledge of the particular services
   being used.  For WSDL/XML services, software developers must be
   familiar with the particular XML schemas consumed and generated by a
   service and must implement transformations of local application data
   to and from those schemas as necessary.  Automatic code generators
   for WSDL clients assist in this task, but developers must still
   understand the structure of the input/output data and the meaning of
   the various components.  Likewise, developers of RESTful clients must
   be familiar with the semantics and permitted values of the named
   parameters for each service and must implement transformations on the
   service output data as necessary.  The requirement on software
   developers to learn and accomodate the particular interfaces and data
   schemas of each service has a high cost in terms of human labour.
   Moreover, variability in the design of schemas and interfaces creates
   obstacles for the coordinated use of web services across different
   providers.

   SADI addresses the variability of data representation through the use
   of Semantic Web standards, namely RDF [RDF] and OWL [OWL].  As these
   standards have been specifically designed to facilitate integration
   and processing of data across multiple sites, they possess
   significant advantages over XML and ad hoc data formats for encoding
   web service input/output.  In particular, RDF enables automated
   merging of data sets and OWL enables automated logical reasoning over
   data.  Meaningful data integration always requires some level of
   agreement between providers regarding data representations.  However,
   under SADI, providers must only agree at the more granular level of
   predicate vocabularies, rather than on complete representations of
   datatypes.

   SADI addresses the variability of service interfaces by proposing
   conventions for retrieving metadata about services and for invoking
   services.  Briefly, metadata about a service is retrievable as an RDF
   document by issuing an HTTP GET to the service URL, while service
   invocation is realized by issuing an HTTP POST to the service URL
   with an input RDF document as the request body.  The response to a
   service invocation is likewise an RDF document.

    <section>
        <h2>Secrity Considerations</h2>
 SADI services and clients are subject to the same security
   considerations as servers and clients that use the HTTP protocol, as
   described in Section 15 of [[HTTP]].

    </section>
    
    <section>
        <h2>Terminology</h2>
   Readers of this document are expected to have a general familiarity
   with the HTTP protocol [[RFC2616]], RDF [[RDF-SYNTAX]], and OWL [[owl-features]].  In
   addition, this document uses the following SADI-specific terminology:

   <ul>
    
   <li>input OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single input to a SADI service.  Each
      SADI service has exactly one input OWL class.</li>

   <li>input instance -- an RDF node that is an instance of the input
      OWL class for a given SADI service, and thus is a valid input for
      that service.  In general, an RDF node is an instance of an OWL class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>
      o  _input RDF document_ -- a document containing one or more input
      instances for a SADI service.  A SADI service is invoked by
      issuing an HTTP POST to the service URL with the input RDF
      document as the request body.

   <li>output OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single output from a SADI service.
      Each SADI service has exactly one output OWL class.</li>

   <li>output instance -- an RDF node that is an instance of the output
      OWL class for a given SADI service, and thus is a valid output for
      that service.  In general, an RDF node is an instance of an OWL
      class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>

   <li>output RDF document -- the result of a SADI service invocation,
      which contains one or more output instances.  For a given service
      invocation, the number of output instances in the output RDF
      document should be equal to the number of input instances in the
      input RDF document.  Further, the URIs of corresponding input and
      output instances are always equal.</li>

   <li>service execution parameter -- a value which is separate from
      the input instances for a service invocation, but affects how the
      input instances are processed.  For example, a "Hello, World!"
      service that returns a natural language greeting might have a
      service execution parameter indicating the desired output language
      for the greeting.</li>

  <li>parameter OWL class -- an OWL class that defines the required
      structure (i.e. schema) of service execution parameters for a SADI
      service.  Similarly to input and output instances, service
      execution parameters may have arbitrarily complex representations
      in RDF.  The parameter OWL class describes a graph that contains
      _all_ service execution parameters.  If a service has multiple
      execution parameters, their RDF representations must be connected
      in a single RDF graph that is an instance of the parameter OWL
      class.</li>

   <li>parameter instance -- an RDF node that is an instance of the
      parameter OWL class for a given SADI service, and thus is a valid
      set of execution parameters for that service.  The input RDF
      document for a service invocation may contain at most one
      parameter instance, which affects the processing of all input
      instances within the input RDF document.</li>

   <li>default parameter instance_ -- an instance of the parameter OWL
      class that represents the default values for all service execution
      parameters.  These values are used when an input RDF document does
      not explicitly specify values for execution parameters.</li>


   </ul>
   
    </section>
    
    <section>
        <h2>Motivation</h2>
        
        The original motivation for the development of SADI was the
   complexity of discoverying, accessing, and integrating public data
   and software in the domain of bioinformatics.  While there are
   currently thousands of interrelated bioinformatics databases and
   software tools freely available on the web, they are published using
   a plethora of incompatible data models, schemas, and software
   interfaces that impedes their combined use.  The authors sought to
   develop a set of best practices for publishing data and software
   resources that would simultaneously offer the benefits of Semantic
   Web standards and technologies, such as the ability to automatically
   merge data sets and to automatically compute logical inferences from
   data.

   While the development of SADI has been motivated by bioinformatics,
   there is nothing that prevents its application to other domains.  It
   is applicable in any scenario where integrating data and/or software
   across multiple sites is required.
    </section>
    <section>
      <h2>Design Goals:</h2>
      <h3>Interoperability with the Semantic Web</h3>
      
       One of the primary goals of SADI is to create web services that are
   compatible with the Semantic Web. In particular, it is desirable that
   services should be able to exchange data directly with various
   consumers and producers of RDF data such as triple stores, static RDF
   documents, OWL reasoners, and RDF browsers.  For this reason, SADI
   services consume a standard RDF document as input and generate a
   standard RDF document as output.

   Another key point of compatibility with the Semantic Web is the use
   of OWL to define the requirements for the input data, output data,
   and execution parameters of a service.  This permits the use of an
OWL reasoner as the main vehicle for data and service matchmaking
   tasks, such as:

   <li>identifying services that can consume a subset of a given RDF
      graph as input</li>

   <li>extracting input instances for a service from a given RDF graph</li>

   <li>matching the output interface of one service to the input
      interface of another service, in order to create service execution
      chains (workflows)</li>

   The intent of SADI is to facilitate the use of web services within
   Semantic Web applications.  For example, the authors have developed a
   prototype query engine called SHARE [SHARE] that integrates SADI
   services with a SPARQL query engine, a triple store, and an OWL
   reasoner in order to answer queries over the data that can be
   generated by a collection of SADI services.
    </section>
    
    <section>
      <h3>Stateless Services</h3>
       The scope of SADI is limited to stateless services so that services
   and clients can be implemented in a straightforward manner, at the
   expense of certain types of advanced applications.  The set of
   stateless services includes services that perform any type of data
   retrieval or data analysis, but excludes services that effect changes
   in the real world.  A common example of the latter type of service is
   a service that makes a withdrawal from a bank account.  Previous
   Semantic Web Service standards such as WSMO and OWL-S have been
   developed to model such stateful services.  However, the formal
   description of stateful services is complex, and the design of
   software agents to coordinate such services is an ongoing research
   problem.
    </section>
    
    
    <section>
      <h3>Batch Processing of Inputs</h3>
    In order to minimize overhead due to network latency, it should be
   possible to group independent inputs for a service into a single
   request, and to receive the corresponding outputs in a single
   response.  In SADI, the input RDF document for a service invocation
   may contain any number of input instances which represent independent
   inputs to the service.  Likewise, the output RDF document may contain
   any number of independent output instances.
    </section>
    
    
    <section>
      <h3>Support for Long-running Services</h3>
    The processing time of a service should not be limited to the
   lifetime of a TCP connection.  Asynchronous SADI services support long-running computations by means of client polling and HTTP
   redirects, as described in Asynchronous Services (Section 10.2).
    </section>
    
    <section>
      <h3>Explicit Relationship Between Service Input and Output</h3>
      It is desirable to ensure that related input and output instances
   from a service invocation are explicitly linked.  This saves a client
   from the task of tracking input/output relationships on its own, and
   ensures that the RDF produced by service invocations forms a
   connected graph that is queriable in a meaningful manner.  In SADI,
   related input and output instances are linked because they share the
   same URI.  This constraint is demonstrated concretely in Running
   Example: The SADI "Hello, World!"  Service (Section 8) and is
   described more formally in The Output OWL Class (Section 9.3.2).
    </section>
    
    <section>
      <h3>Minimal Constraints on Data Modeling</h3>
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    </section>
    
    <section>
      <h2>Relationship to Other Web Service Standards</h2>
      
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    
      <h3>Web Services Description Language (WSDL)</h3>

   WSDL [[WSDL]] is an XML schema that is the current de facto standard
   for machine-readable description of web service interfaces.  At the
   time of writing this document, the most recent version of WSDL is
   WSDL 2.0.

   The most important difference between SADI and WSDL is that SADI uses
   RDF for message content, whereas WSDL conventionally uses XML.  WSDL
   uses XML Schema [[XSD]] as the default schema language for
   message structures, but is also extensible to use other schema
   languages.  To date, there have been proposals for extensions that
   use Document Type Definitions (DTDs) and RelaxNG as alternative
   schema languages for WSDL.  In principle, a similar extension could
   be created for the use of OWL as a schema language, although none has
   been put forward to date.

   SADI uses only a small, fixed subset of the behaviours that can
   described by WSDL.  In the terminology of WSDL, SADI services must
    have:

   <li>one operation per service_, where an _operation_ is interaction
      between the client and the service to accomplish some result.  An
      operation is analogous to a function call in a programming
      language.</li>

   <li>one endpoint per service_, where an _endpoint_ is an URL where
      the client interacts with the service</li>

   <li>a fixed protocol_, where the _protocol_ is the mechanism for
      transporting messages between the client and the service.  All
      SADI services use HTTP as the underlying protocol.</li>

   <li>a fixed message exchange pattern_, where a _message exchange
      pattern_ is a sequence of messages that are exchanged between a
      client and a service during an operation.  SADI services have one
      of two possible message exchange patterns, corresponding to
      synchronous services (Section 10.1) and asynchronous services
      (Section 10.2).</li>

   The only variables of a SADI service interface are the graph
   representations of the input data, the output data, and the service
   execution parameters, which are defined by the input OWL class
   (Section 9.3.1), the output OWL class (Section 9.3.2), and the
   parameter OWL class (Section 9.4.1), respectively.  For SADI, these
   three OWL classes are the functional analog of a WSDL service
   description file.




      <h3>Semantic Annotations for WSDL (SAWSDL)</h3>

   SAWSDL [SAWSDL] is a small set of extensions to the WSDL XML schema
   that facilitates the mapping of XML-based services to a semantic data
   model (e.g.  RDF).  Specifically, SAWSDL defines 3 additional XML
   attributes for WSDL:

   <li> modelReference</li>

   <li> loweringSchemaMapping</li>

   <li> liftingSchemaMapping</li>

   <i>modelReference</i> is used to annotate elements of a WSDL interface
   with entities from a semantic data model, such as class URIs from an
   OWL ontology. <i>liftingSchemaMapping</i> and <i>loweringSchemaMapping</i> are
   used to provide mappings of XML datatypes to and from a semantic data
   model, respectively.  The values of <i>liftingSchemaMapping</i> and
   <i>loweringSchema</i> are URIs that identify documents that define the
 transformation; however, SAWSDL is agnostic with respect to the
   specific mapping language that is used.  For example, when
   translating between XML and RDF, the required mappings might be
   accomplished with XSLT for the lifting transformation and SPARQL
   followed by XSLT for the lowering transformation.

   SAWSDL can be used as an adaptor layer that maps a WSDL service to
   the expected behaviour of a SADI service.
   



      <h3>OWL-S and the Web Service Modeling Ontology (WSMO)</h3>

   OWL-S [[OWL-S]] and WSMO [[WSMO]] are two previous Semantic Web Services
   standards that are similar in their goals and approaches.  Both
   standards define ontologies for describing the _capablities_ and
   _choreographies_ of stateful web services, where capabilities are
   changes to the world that are effected by a service, and
   choreographies are the sequences of messages exchanged between a
   client and a service during an interaction.  (Choreographies
   correspond to message exchange patterns in WSDL.)  OWL-S and WSMO
   exceed the descriptive power of WSDL by providing a generic framework
   for modeling both the internal state of a service and the state of
   external variables that are affected by the service (e.g. a credit
   card balance).  Transitions between states are formally described by
   boolean formulas that express preconditions and postconditions for an
   event.

   The principal difference between OWL-S and WSMO is that OWL-S uses
   OWL as its ontology language, whereas WSMO uses a more expressive
   language called the Web Service Modeling Language (WSML).  The OWL-S
   and WSMO standards are complex, and the development of software
   agents to coordinate OWL-S/WSMO services to accomplish higher order
   tasks in an ongoing area of research.

   In comparison to OWL-S and WSMO, SADI is a simpler standard that is
   limited to the description of stateless services.  SADI uses OWL
   ontologies only for defining the schema of input data, output data,
   and service execution parameters, and not to define the effects or
   choreography of a service.  The choreography of a SADI service is
   fixed to one of two possibilities, corresponding to synchronous
   services (Section 10.1) and asynchronous services (Section 10.2)
   respectively.
   
    </section>
    
    <section>
      <h2> Running Example: The SADI "Hello, World!" Service</h2>
        To illustrate the different aspects of the SADI protocol in a
   concrete manner, we will frequently make reference to the SADI
   "Hello, World!" service located at
   http://sadiframework.org/examples/hello.  The purpose of this section
   is to describe the behaviour of this service and at the same time to
   provide a brief, non-normative introduction to the key aspects of the
   SADI protocol.

   The SADI "Hello, World!" service consumes one or more input instances
   representing people with names (e.g.  "Guy Incognito") and returns
   corresponding output instances representing greetings for each person
   (e.g.  "Hello, Guy Incognito!").  The following shows an example
   input RDF document for the service, in N3:
      
  
  
      <pre class='example highlight'>
              @prefix foaf: &lt;http://xmlns.com/foaf/0.1/> .
      @prefix hello: &lt;http://sadiframework.org/examples/hello.owl#> .
      @prefix input: &lt;http://sadiframework.org/data/examples/hello-input
.n3#> .

      input:GuyIncognito
          a hello:NamedIndividual;
          foaf:name "Guy Incognito" .

      input:HomerSimpson
          a hello:NamedIndividual;
          foaf:name "Homer Simpson" .

      </pre>
      
         In response, the service generates the following output RDF document:
         
         <pre class='example highlight'>
                @prefix hello: &lt;http://sadiframework.org/examples/hello.owl#> .
      @prefix input: &lt;http://sadiframework.org/data/examples/hello-input
.n3#> .

      input:GuyIncognito
          a hello:GreetedIndividual;
          hello:greeting "Hello, Guy Incognito!" .

      input:HomerSimpson
          a hello:GreetedIndividual;
          hello:greeting "Hello, Homer Simpson!" .
         </pre>
         
  
    </section>
    
</body>
</html>
