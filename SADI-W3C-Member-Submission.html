<!DOCTYPE html>
<html>
  <head>
    <title>Semantic Automated Discovery and Integration</title>
    <meta charset='utf-8'/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "Member-SUBM",
          shortName:  "SADI",
          previousMaturity: "FPWD",
          previousPublishDate:  "2016-1-25",
          logos: [
               {
                  src: "http://sadiframework.org/content/wp-content/themes/SADI/images/sadi-header.png",
                  href: "http://sadiframework.org",
                  alt: "SADI - Semantic Automated Discovery and Integration",
                  width: 300,
                  id: 'SADILogo'
               }
            ],
         
          editors: [
                {   name:       "Mark Wilkinson",
                    url:        "http://wilkinsonlab.info/",
                    company:    "CBGP-UPM",
                    companyURL: "http://www.cbgp.upm.es/" },
                {   name:       "Michel Dumontier",
                    url:        "http://semanticscience.org/",
                    company:    "Stanford University",
                    companyURL: "http://www.stanford.edu/"},
                {   name:       "Luke McCarthy",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Benjamin Vandervalk (original author)",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Chris Baker",
                },
                {   name:       "Alexandre R.",
                    url:        "http://wilkinsonlab.info/",
                },
          ],
          wg:           "HCLS",
          wgURI:        "https://www.w3.org/blog/hcls/",
          wgPublicList: "",
          wgPatentURI:  "",
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes Semantic Automated Discovery and Integration
   (SADI), a set of best practices for implementing stateless web
   services that consume RDF data as input and generate RDF data as
   output.  The goal of SADI is to establish conventions that will
   enable a much higher level of interoperability between web services
   from independent providers than is currently possible under the
   widespread use of WSDL/XML and RESTful services.  Under SADI,
   interoperability depends on the shared use of predicate vocabularies,
   rather than the shared use of particular XML schemas, JSON
   structures, or ad hoc data formats.  Through the use of OWL to
   describe service input and output datatypes, SADI enables: i)
   automated discovery of services that provide data or computations of
   interest, and ii) automated matchmaking between local data and
   available services.  By iterative application of the former two
   capabilities, SADI enables semi-automated construction of arbitrarily
   complex workflows across independent service providers.
      </p>
    </section>

    <section id='sotd'>
      <p>
 </p>
    </section>
    
    <section class='informative'>
      <h2>Executive Summary</h2>
      <p>
SADI is a set of best practices for implementing stateless web
   services that natively consume RDF data as input and generate RDF
   data as output.  Its primary purpose is to increase the
   interoperability of services across independent providers.  Under
   SADI, the schemas for the input and output RDF data of a service are
   defined by the service's _input OWL class_ and _output OWL class_,
   respectively.  Provider-specified metadata about a service, including
   the URIs of the input and output OWL classes, is published as an RDF
   document that is retrievable by an HTTP GET on the service URL.
   Service invocation is accomplished by issuing an HTTP POST request to
   the service URL with an appropriate input RDF document as the request
   body.  The input RDF document contains one or more instances of the
   input OWL class which represent independent inputs to the service,
   and in response the service returns an output RDF document with a
   corresponding number of instances of the output OWL class.  Each
   output instance has the same root URI as its corresponding input
   instance, in order to ensure that the data consumed and generated by
   the service are explicitly linked.
    </section>
    <section class='conformance'>
      <h2>Conformance</h2>
      As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

The key words MUST, MUST NOT, REQUIRED,SHOULD,SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this specification are to be interpreted as described in [[RFC2119]].

    </section>
    <section>
        <h2>Introduction</h2>

The principal benefit of web services is that they enable widespread
   and convenient reuse of software components, independent of the
   larger applications or goals being realized by the client software.
   However, in the current climate of WSDL/XML [[WSDL]] and RESTful
   services [[REST]], the successful implementation of web service clients
   still depends on detailed human knowledge of the particular services
   being used.  For WSDL/XML services, software developers must be
   familiar with the particular XML schemas consumed and generated by a
   service and must implement transformations of local application data
   to and from those schemas as necessary.  Automatic code generators
   for WSDL clients assist in this task, but developers must still
   understand the structure of the input/output data and the meaning of
   the various components.  Likewise, developers of RESTful clients must
   be familiar with the semantics and permitted values of the named
   parameters for each service and must implement transformations on the
   service output data as necessary.  The requirement on software
   developers to learn and accomodate the particular interfaces and data
   schemas of each service has a high cost in terms of human labour.
   Moreover, variability in the design of schemas and interfaces creates
   obstacles for the coordinated use of web services across different
   providers.

   SADI addresses the variability of data representation through the use
   of Semantic Web standards, namely RDF [RDF] and OWL [OWL].  As these
   standards have been specifically designed to facilitate integration
   and processing of data across multiple sites, they possess
   significant advantages over XML and ad hoc data formats for encoding
   web service input/output.  In particular, RDF enables automated
   merging of data sets and OWL enables automated logical reasoning over
   data.  Meaningful data integration always requires some level of
   agreement between providers regarding data representations.  However,
   under SADI, providers must only agree at the more granular level of
   predicate vocabularies, rather than on complete representations of
   datatypes.

   SADI addresses the variability of service interfaces by proposing
   conventions for retrieving metadata about services and for invoking
   services.  Briefly, metadata about a service is retrievable as an RDF
   document by issuing an HTTP GET to the service URL, while service
   invocation is realized by issuing an HTTP POST to the service URL
   with an input RDF document as the request body.  The response to a
   service invocation is likewise an RDF document.

    <section>
        <h2>Secrity Considerations</h2>
 SADI services and clients are subject to the same security
   considerations as servers and clients that use the HTTP protocol, as
   described in Section 15 of [[HTTP]].

    </section>
    
    <section>
        <h2>Terminology</h2>
   Readers of this document are expected to have a general familiarity
   with the HTTP protocol [[RFC2616]], RDF [[RDF-SYNTAX]], and OWL [[owl-features]].  In
   addition, this document uses the following SADI-specific terminology:

   <ul>
    
   <li>input OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single input to a SADI service.  Each
      SADI service has exactly one input OWL class.</li>

   <li>input instance -- an RDF node that is an instance of the input
      OWL class for a given SADI service, and thus is a valid input for
      that service.  In general, an RDF node is an instance of an OWL class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>
      o  _input RDF document_ -- a document containing one or more input
      instances for a SADI service.  A SADI service is invoked by
      issuing an HTTP POST to the service URL with the input RDF
      document as the request body.

   <li>output OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single output from a SADI service.
      Each SADI service has exactly one output OWL class.</li>

   <li>output instance -- an RDF node that is an instance of the output
      OWL class for a given SADI service, and thus is a valid output for
      that service.  In general, an RDF node is an instance of an OWL
      class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>

   <li>output RDF document -- the result of a SADI service invocation,
      which contains one or more output instances.  For a given service
      invocation, the number of output instances in the output RDF
      document should be equal to the number of input instances in the
      input RDF document.  Further, the URIs of corresponding input and
      output instances are always equal.</li>

   <li>service execution parameter -- a value which is separate from
      the input instances for a service invocation, but affects how the
      input instances are processed.  For example, a "Hello, World!"
      service that returns a natural language greeting might have a
      service execution parameter indicating the desired output language
      for the greeting.</li>

  <li>parameter OWL class -- an OWL class that defines the required
      structure (i.e. schema) of service execution parameters for a SADI
      service.  Similarly to input and output instances, service
      execution parameters may have arbitrarily complex representations
      in RDF.  The parameter OWL class describes a graph that contains
      _all_ service execution parameters.  If a service has multiple
      execution parameters, their RDF representations must be connected
      in a single RDF graph that is an instance of the parameter OWL
      class.</li>

   <li>parameter instance -- an RDF node that is an instance of the
      parameter OWL class for a given SADI service, and thus is a valid
      set of execution parameters for that service.  The input RDF
      document for a service invocation may contain at most one
      parameter instance, which affects the processing of all input
      instances within the input RDF document.</li>

   <li>default parameter instance_ -- an instance of the parameter OWL
      class that represents the default values for all service execution
      parameters.  These values are used when an input RDF document does
      not explicitly specify values for execution parameters.</li>


   </ul>
   
    </section>
    
    <section>
        <h2>Motivation</h2>
        
        The original motivation for the development of SADI was the
   complexity of discoverying, accessing, and integrating public data
   and software in the domain of bioinformatics.  While there are
   currently thousands of interrelated bioinformatics databases and
   software tools freely available on the web, they are published using
   a plethora of incompatible data models, schemas, and software
   interfaces that impedes their combined use.  The authors sought to
   develop a set of best practices for publishing data and software
   resources that would simultaneously offer the benefits of Semantic
   Web standards and technologies, such as the ability to automatically
   merge data sets and to automatically compute logical inferences from
   data.

   While the development of SADI has been motivated by bioinformatics,
   there is nothing that prevents its application to other domains.  It
   is applicable in any scenario where integrating data and/or software
   across multiple sites is required.
    </section>
    <section>
      <h2>Design Goals:</h2>
      <h3>Interoperability with the Semantic Web</h3>
      
       One of the primary goals of SADI is to create web services that are
   compatible with the Semantic Web. In particular, it is desirable that
   services should be able to exchange data directly with various
   consumers and producers of RDF data such as triple stores, static RDF
   documents, OWL reasoners, and RDF browsers.  For this reason, SADI
   services consume a standard RDF document as input and generate a
   standard RDF document as output.

   Another key point of compatibility with the Semantic Web is the use
   of OWL to define the requirements for the input data, output data,
   and execution parameters of a service.  This permits the use of an
OWL reasoner as the main vehicle for data and service matchmaking
   tasks, such as:

   <li>identifying services that can consume a subset of a given RDF
      graph as input</li>

   <li>extracting input instances for a service from a given RDF graph</li>

   <li>matching the output interface of one service to the input
      interface of another service, in order to create service execution
      chains (workflows)</li>

   The intent of SADI is to facilitate the use of web services within
   Semantic Web applications.  For example, the authors have developed a
   prototype query engine called SHARE [SHARE] that integrates SADI
   services with a SPARQL query engine, a triple store, and an OWL
   reasoner in order to answer queries over the data that can be
   generated by a collection of SADI services.
    </section>
    
    <section>
      <h3>Stateless Services</h3>
       The scope of SADI is limited to stateless services so that services
   and clients can be implemented in a straightforward manner, at the
   expense of certain types of advanced applications.  The set of
   stateless services includes services that perform any type of data
   retrieval or data analysis, but excludes services that effect changes
   in the real world.  A common example of the latter type of service is
   a service that makes a withdrawal from a bank account.  Previous
   Semantic Web Service standards such as WSMO and OWL-S have been
   developed to model such stateful services.  However, the formal
   description of stateful services is complex, and the design of
   software agents to coordinate such services is an ongoing research
   problem.
    </section>
    
    
    <section>
      <h3>Batch Processing of Inputs</h3>
    In order to minimize overhead due to network latency, it should be
   possible to group independent inputs for a service into a single
   request, and to receive the corresponding outputs in a single
   response.  In SADI, the input RDF document for a service invocation
   may contain any number of input instances which represent independent
   inputs to the service.  Likewise, the output RDF document may contain
   any number of independent output instances.
    </section>
    
    
    <section>
      <h3>Support for Long-running Services</h3>
    The processing time of a service should not be limited to the
   lifetime of a TCP connection.  Asynchronous SADI services support long-running computations by means of client polling and HTTP
   redirects, as described in Asynchronous Services (Section 10.2).
    </section>
    
    <section>
      <h3>Explicit Relationship Between Service Input and Output</h3>
      It is desirable to ensure that related input and output instances
   from a service invocation are explicitly linked.  This saves a client
   from the task of tracking input/output relationships on its own, and
   ensures that the RDF produced by service invocations forms a
   connected graph that is queriable in a meaningful manner.  In SADI,
   related input and output instances are linked because they share the
   same URI.  This constraint is demonstrated concretely in Running
   Example: The SADI "Hello, World!"  Service (Section 8) and is
   described more formally in The Output OWL Class (Section 9.3.2).
    </section>
    
    <section>
      <h3>Minimal Constraints on Data Modeling</h3>
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    </section>
    
    <section>
      <h2>Relationship to Other Web Service Standards</h2>
      
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    </section>
    
    
    
</body>
</html>
