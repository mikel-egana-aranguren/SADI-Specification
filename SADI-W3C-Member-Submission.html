<!DOCTYPE html>
<html>
  <head>
    <title>Semantic Automated Discovery and Integration</title>
    <meta charset='utf-8'/>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common'
            class='remove'></script>
    <script class='remove'>
      var respecConfig = {
          specStatus: "Member-SUBM",
          shortName:  "SADI",
          previousMaturity: "FPWD",
          previousPublishDate:  "2016-1-25",
          
          localBiblio:  {
            "OWL-S": {
               title:    "OWL-S: Semantic Markup for Web Services",
               href:     "https://www.w3.org/Submission/OWL-S/",
              publisher:  "W3C"
            }
          },
          
          logos: [
               {
                  src: "http://sadiframework.org/content/wp-content/themes/SADI/images/sadi-header.png",
                  href: "http://sadiframework.org",
                  alt: "SADI - Semantic Automated Discovery and Integration",
                  width: 300,
                  id: 'SADILogo'
               }
            ],
         
          editors: [
                {   name:       "Mark Wilkinson",
                    url:        "http://wilkinsonlab.info/",
                    company:    "CBGP-UPM",
                    companyURL: "http://www.cbgp.upm.es/" },
                {   name:       "Michel Dumontier",
                    url:        "http://semanticscience.org/",
                    company:    "Stanford University",
                    companyURL: "http://www.stanford.edu/"},
                {   name:       "Luke McCarthy",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Benjamin Vandervalk (original author)",
                    url:        "http://wilkinsonlab.info/",
                },
                {   name:       "Chris Baker",
                    url:        "",
                    company: "University of New Brunswick",
                    companyURL: "http://www.unb.ca/"
                },
                {   name:       "Alexander Ryazanov",
                    url:        "",
                },
          ],
          wg:           "HCLS",
          wgURI:        "https://www.w3.org/blog/hcls/",
          wgPublicList: "",
          wgPatentURI:  "",
      };
    </script>
  </head>
  <body>
    <section id='abstract'>
      <p>
        This document describes Semantic Automated Discovery and Integration
   (SADI), a set of best practices for implementing stateless web
   services that consume RDF data as input and generate RDF data as
   output.  The goal of SADI is to establish conventions that will
   enable a much higher level of interoperability between web services
   from independent providers than is currently possible under the
   widespread use of WSDL/XML and RESTful services.  Under SADI,
   interoperability depends on the shared use of predicate vocabularies,
   rather than the shared use of particular XML schemas, JSON
   structures, or ad hoc data formats.  Through the use of OWL to
   describe service input and output datatypes, SADI enables: i)
   automated discovery of services that provide data or computations of
   interest, and ii) automated matchmaking between local data and
   available services.  By iterative application of the former two
   capabilities, SADI enables semi-automated construction of arbitrarily
   complex workflows across independent service providers.
      </p>
    </section>

    <section id='sotd'>
      <p>
 </p>
    </section>
    
    <section class='informative'>
      <h2>Executive Summary</h2>
      <p>
SADI is a set of best practices for implementing stateless web
   services that natively consume RDF data as input and generate RDF
   data as output.  Its primary purpose is to increase the
   interoperability of services across independent providers.  Under
   SADI, the schemas for the input and output RDF data of a service are
   defined by the service's _input OWL class_ and _output OWL class_,
   respectively.  Provider-specified metadata about a service, including
   the URIs of the input and output OWL classes, is published as an RDF
   document that is retrievable by an HTTP GET on the service URL.
   Service invocation is accomplished by issuing an HTTP POST request to
   the service URL with an appropriate input RDF document as the request
   body.  The input RDF document contains one or more instances of the
   input OWL class which represent independent inputs to the service,
   and in response the service returns an output RDF document with a
   corresponding number of instances of the output OWL class.  Each
   output instance has the same root URI as its corresponding input
   instance, in order to ensure that the data consumed and generated by
   the service are explicitly linked.
    </section>
    <section class='conformance'>
      <h2>Conformance</h2>
      As well as sections marked as non-normative, all authoring guidelines, diagrams, examples, and notes in this specification are non-normative. Everything else in this specification is normative.

The key words MUST, MUST NOT, REQUIRED,SHOULD,SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this specification are to be interpreted as described in [[RFC2119]].

    </section>
    <section>
        <h2>Introduction</h2>

The principal benefit of web services is that they enable widespread
   and convenient reuse of software components, independent of the
   larger applications or goals being realized by the client software.
   However, in the current climate of WSDL/XML [[WSDL]] and RESTful
   services [[REST]], the successful implementation of web service clients
   still depends on detailed human knowledge of the particular services
   being used.  For WSDL/XML services, software developers must be
   familiar with the particular XML schemas consumed and generated by a
   service and must implement transformations of local application data
   to and from those schemas as necessary.  Automatic code generators
   for WSDL clients assist in this task, but developers must still
   understand the structure of the input/output data and the meaning of
   the various components.  Likewise, developers of RESTful clients must
   be familiar with the semantics and permitted values of the named
   parameters for each service and must implement transformations on the
   service output data as necessary.  The requirement on software
   developers to learn and accomodate the particular interfaces and data
   schemas of each service has a high cost in terms of human labour.
   Moreover, variability in the design of schemas and interfaces creates
   obstacles for the coordinated use of web services across different
   providers.

   SADI addresses the variability of data representation through the use
   of Semantic Web standards, namely RDF [RDF] and OWL [OWL].  As these
   standards have been specifically designed to facilitate integration
   and processing of data across multiple sites, they possess
   significant advantages over XML and ad hoc data formats for encoding
   web service input/output.  In particular, RDF enables automated
   merging of data sets and OWL enables automated logical reasoning over
   data.  Meaningful data integration always requires some level of
   agreement between providers regarding data representations.  However,
   under SADI, providers must only agree at the more granular level of
   predicate vocabularies, rather than on complete representations of
   datatypes.

   SADI addresses the variability of service interfaces by proposing
   conventions for retrieving metadata about services and for invoking
   services.  Briefly, metadata about a service is retrievable as an RDF
   document by issuing an HTTP GET to the service URL, while service
   invocation is realized by issuing an HTTP POST to the service URL
   with an input RDF document as the request body.  The response to a
   service invocation is likewise an RDF document.

    <section>
        <h2>Secrity Considerations</h2>
 SADI services and clients are subject to the same security
   considerations as servers and clients that use the HTTP protocol, as
   described in Section 15 of [[RFC2616]].

    </section>
    
    <section>
        <h2>Terminology</h2>
   Readers of this document are expected to have a general familiarity
   with the HTTP protocol [[RFC2616]], RDF [[RDF-SYNTAX]], and OWL [[owl-features]].  In
   addition, this document uses the following SADI-specific terminology:

   <ul>
    
   <li>input OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single input to a SADI service.  Each
      SADI service has exactly one input OWL class.</li>

   <li>input instance -- an RDF node that is an instance of the input
      OWL class for a given SADI service, and thus is a valid input for
      that service.  In general, an RDF node is an instance of an OWL class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>
      <li>input RDF document_ -- a document containing one or more input
      instances for a SADI service.  A SADI service is invoked by
      issuing an HTTP POST to the service URL with the input RDF
      document as the request body.

   <li>output OWL class -- an OWL class that defines the required
      structure (i.e. schema) of a single output from a SADI service.
      Each SADI service has exactly one output OWL class.</li>

   <li>output instance -- an RDF node that is an instance of the output
      OWL class for a given SADI service, and thus is a valid output for
      that service.  In general, an RDF node is an instance of an OWL
      class if it satifisies the property restrictions of the OWL class.
      Membership of an RDF node in a given OWL class can be determined
      using an OWL reasoner or can be directly asserted by assigning an
      rdf:type value that is equal to the OWL class URI.</li>

   <li>output RDF document -- the result of a SADI service invocation,
      which contains one or more output instances.  For a given service
      invocation, the number of output instances in the output RDF
      document should be equal to the number of input instances in the
      input RDF document.  Further, the URIs of corresponding input and
      output instances are always equal.</li>

   <li>service execution parameter -- a value which is separate from
      the input instances for a service invocation, but affects how the
      input instances are processed.  For example, a "Hello, World!"
      service that returns a natural language greeting might have a
      service execution parameter indicating the desired output language
      for the greeting.</li>

  <li>parameter OWL class -- an OWL class that defines the required
      structure (i.e. schema) of service execution parameters for a SADI
      service.  Similarly to input and output instances, service
      execution parameters may have arbitrarily complex representations
      in RDF.  The parameter OWL class describes a graph that contains
      _all_ service execution parameters.  If a service has multiple
      execution parameters, their RDF representations must be connected
      in a single RDF graph that is an instance of the parameter OWL
      class.</li>

   <li>parameter instance -- an RDF node that is an instance of the
      parameter OWL class for a given SADI service, and thus is a valid
      set of execution parameters for that service.  The input RDF
      document for a service invocation may contain at most one
      parameter instance, which affects the processing of all input
      instances within the input RDF document.</li>

   <li>default parameter instance_ -- an instance of the parameter OWL
      class that represents the default values for all service execution
      parameters.  These values are used when an input RDF document does
      not explicitly specify values for execution parameters.</li>


   </ul>
   
    </section>
    
    <section>
        <h2>Motivation</h2>
        
        The original motivation for the development of SADI was the
   complexity of discoverying, accessing, and integrating public data
   and software in the domain of bioinformatics.  While there are
   currently thousands of interrelated bioinformatics databases and
   software tools freely available on the web, they are published using
   a plethora of incompatible data models, schemas, and software
   interfaces that impedes their combined use.  The authors sought to
   develop a set of best practices for publishing data and software
   resources that would simultaneously offer the benefits of Semantic
   Web standards and technologies, such as the ability to automatically
   merge data sets and to automatically compute logical inferences from
   data.

   While the development of SADI has been motivated by bioinformatics,
   there is nothing that prevents its application to other domains.  It
   is applicable in any scenario where integrating data and/or software
   across multiple sites is required.
    </section>
    <section>
      <h2>Design Goals:</h2>
      <h3>Interoperability with the Semantic Web</h3>
      
       One of the primary goals of SADI is to create web services that are
   compatible with the Semantic Web. In particular, it is desirable that
   services should be able to exchange data directly with various
   consumers and producers of RDF data such as triple stores, static RDF
   documents, OWL reasoners, and RDF browsers.  For this reason, SADI
   services consume a standard RDF document as input and generate a
   standard RDF document as output.

   Another key point of compatibility with the Semantic Web is the use
   of OWL to define the requirements for the input data, output data,
   and execution parameters of a service.  This permits the use of an
OWL reasoner as the main vehicle for data and service matchmaking
   tasks, such as:

   <li>identifying services that can consume a subset of a given RDF
      graph as input</li>

   <li>extracting input instances for a service from a given RDF graph</li>

   <li>matching the output interface of one service to the input
      interface of another service, in order to create service execution
      chains (workflows)</li>

   The intent of SADI is to facilitate the use of web services within
   Semantic Web applications.  For example, the authors have developed a
   prototype query engine called SHARE [SHARE] that integrates SADI
   services with a SPARQL query engine, a triple store, and an OWL
   reasoner in order to answer queries over the data that can be
   generated by a collection of SADI services.
    </section>
    
    <section>
      <h3>Stateless Services</h3>
       The scope of SADI is limited to stateless services so that services
   and clients can be implemented in a straightforward manner, at the
   expense of certain types of advanced applications.  The set of
   stateless services includes services that perform any type of data
   retrieval or data analysis, but excludes services that effect changes
   in the real world.  A common example of the latter type of service is
   a service that makes a withdrawal from a bank account.  Previous
   Semantic Web Service standards such as WSMO and OWL-S have been
   developed to model such stateful services.  However, the formal
   description of stateful services is complex, and the design of
   software agents to coordinate such services is an ongoing research
   problem.
    </section>
    
    
    <section>
      <h3>Batch Processing of Inputs</h3>
    In order to minimize overhead due to network latency, it should be
   possible to group independent inputs for a service into a single
   request, and to receive the corresponding outputs in a single
   response.  In SADI, the input RDF document for a service invocation
   may contain any number of input instances which represent independent
   inputs to the service.  Likewise, the output RDF document may contain
   any number of independent output instances.
    </section>
    
    
    <section>
      <h3>Support for Long-running Services</h3>
    The processing time of a service should not be limited to the
   lifetime of a TCP connection.  Asynchronous SADI services support long-running computations by means of client polling and HTTP
   redirects, as described in Asynchronous Services (Section 10.2).
    </section>
    
    <section>
      <h3>Explicit Relationship Between Service Input and Output</h3>
      It is desirable to ensure that related input and output instances
   from a service invocation are explicitly linked.  This saves a client
   from the task of tracking input/output relationships on its own, and
   ensures that the RDF produced by service invocations forms a
   connected graph that is queriable in a meaningful manner.  In SADI,
   related input and output instances are linked because they share the
   same URI.  This constraint is demonstrated concretely in Running
   Example: The SADI "Hello, World!"  Service (Section 8) and is
   described more formally in The Output OWL Class (Section 9.3.2).
    </section>
    
    <section>
      <h3>Minimal Constraints on Data Modeling</h3>
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    </section>
    
    <section>
      <h2>Relationship to Other Web Service Standards</h2>
      
   Aside from the constraint of the previous section, SADI does not
   provide any rules about how service input and output data should be
   modeled in RDF.  Service providers are free to encode the data using
   any OWL or RDFS ontologies deemed suitable.  Further, the input and
   output RDF documents for a service invocation consist only of data
   that is consumed or generated by the service, respectively.  There
   are no SADI-specific messaging structures required within the input/
   output RDF documents.
    
      <h3>Web Services Description Language (WSDL)</h3>

   WSDL [[WSDL]] is an XML schema that is the current de facto standard
   for machine-readable description of web service interfaces.  At the
   time of writing this document, the most recent version of WSDL is
   WSDL 2.0.

   The most important difference between SADI and WSDL is that SADI uses
   RDF for message content, whereas WSDL conventionally uses XML.  WSDL
   uses XML Schema [[XSD]] as the default schema language for
   message structures, but is also extensible to use other schema
   languages.  To date, there have been proposals for extensions that
   use Document Type Definitions (DTDs) and RelaxNG as alternative
   schema languages for WSDL.  In principle, a similar extension could
   be created for the use of OWL as a schema language, although none has
   been put forward to date.

   SADI uses only a small, fixed subset of the behaviours that can
   described by WSDL.  In the terminology of WSDL, SADI services must
    have:
<ul>
   <li>one operation per service_, where an _operation_ is interaction
      between the client and the service to accomplish some result.  An
      operation is analogous to a function call in a programming
      language.</li>

   <li>one endpoint per service_, where an _endpoint_ is an URL where
      the client interacts with the service</li>

   <li>a fixed protocol_, where the _protocol_ is the mechanism for
      transporting messages between the client and the service.  All
      SADI services use HTTP as the underlying protocol.</li>

   <li>a fixed message exchange pattern_, where a _message exchange
      pattern_ is a sequence of messages that are exchanged between a
      client and a service during an operation.  SADI services have one
      of two possible message exchange patterns, corresponding to
      synchronous services (Section 10.1) and asynchronous services
      (Section 10.2).</li>
</ul>
   The only variables of a SADI service interface are the graph
   representations of the input data, the output data, and the service
   execution parameters, which are defined by the input OWL class
   (Section 9.3.1), the output OWL class (Section 9.3.2), and the
   parameter OWL class (Section 9.4.1), respectively.  For SADI, these
   three OWL classes are the functional analog of a WSDL service
   description file.




      <h3>Semantic Annotations for WSDL (SAWSDL)</h3>

   SAWSDL [SAWSDL] is a small set of extensions to the WSDL XML schema
   that facilitates the mapping of XML-based services to a semantic data
   model (e.g.  RDF).  Specifically, SAWSDL defines 3 additional XML
   attributes for WSDL:
<ul>
   <li> modelReference</li>

   <li> loweringSchemaMapping</li>

   <li> liftingSchemaMapping</li>
</ul>
   <i>modelReference</i> is used to annotate elements of a WSDL interface
   with entities from a semantic data model, such as class URIs from an
   OWL ontology. <i>liftingSchemaMapping</i> and <i>loweringSchemaMapping</i> are
   used to provide mappings of XML datatypes to and from a semantic data
   model, respectively.  The values of <i>liftingSchemaMapping</i> and
   <i>loweringSchema</i> are URIs that identify documents that define the
 transformation; however, SAWSDL is agnostic with respect to the
   specific mapping language that is used.  For example, when
   translating between XML and RDF, the required mappings might be
   accomplished with XSLT for the lifting transformation and SPARQL
   followed by XSLT for the lowering transformation.

   SAWSDL can be used as an adaptor layer that maps a WSDL service to
   the expected behaviour of a SADI service.
   



      <h3>OWL-S and the Web Service Modeling Ontology (WSMO)</h3>

   OWL-S [[OWL-S]] and WSMO [[WSMO]] are two previous Semantic Web Services
   standards that are similar in their goals and approaches.  Both
   standards define ontologies for describing the _capablities_ and
   _choreographies_ of stateful web services, where capabilities are
   changes to the world that are effected by a service, and
   choreographies are the sequences of messages exchanged between a
   client and a service during an interaction.  (Choreographies
   correspond to message exchange patterns in WSDL.)  OWL-S and WSMO
   exceed the descriptive power of WSDL by providing a generic framework
   for modeling both the internal state of a service and the state of
   external variables that are affected by the service (e.g. a credit
   card balance).  Transitions between states are formally described by
   boolean formulas that express preconditions and postconditions for an
   event.

   The principal difference between OWL-S and WSMO is that OWL-S uses
   OWL as its ontology language, whereas WSMO uses a more expressive
   language called the Web Service Modeling Language (WSML).  The OWL-S
   and WSMO standards are complex, and the development of software
   agents to coordinate OWL-S/WSMO services to accomplish higher order
   tasks in an ongoing area of research.

   In comparison to OWL-S and WSMO, SADI is a simpler standard that is
   limited to the description of stateless services.  SADI uses OWL
   ontologies only for defining the schema of input data, output data,
   and service execution parameters, and not to define the effects or
   choreography of a service.  The choreography of a SADI service is
   fixed to one of two possibilities, corresponding to synchronous
   services (Section 10.1) and asynchronous services (Section 10.2)
   respectively.
   
    </section>
    
    <section>
      <h2> Running Example: The SADI "Hello, World!" Service</h2>
        To illustrate the different aspects of the SADI protocol in a
   concrete manner, we will frequently make reference to the SADI
   "Hello, World!" service located at
   http://sadiframework.org/examples/hello.  The purpose of this section
   is to describe the behaviour of this service and at the same time to
   provide a brief, non-normative introduction to the key aspects of the
   SADI protocol.

   The SADI "Hello, World!" service consumes one or more input instances
   representing people with names (e.g.  "Guy Incognito") and returns
   corresponding output instances representing greetings for each person
   (e.g.  "Hello, Guy Incognito!").  The following shows an example
   input RDF document for the service, in N3:
      
  
  
      <pre class='example highlight'>
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/> .
  @prefix hello: &lt;http://sadiframework.org/examples/hello.owl#> .
  @prefix input: &lt;http://sadiframework.org/data/examples/hello-input.n3#> .
  
  input:GuyIncognito
    a hello:NamedIndividual;
    foaf:name "Guy Incognito" .
  
  input:HomerSimpson
    a hello:NamedIndividual;
    foaf:name "Homer Simpson" .

      </pre>
      
         In response, the service generates the following output RDF document:
         
         <pre class='example highlight'>
  @prefix hello: &lt;http://sadiframework.org/examples/hello.owl#> .
  @prefix input: &lt;http://sadiframework.org/data/examples/hello-input .n3#> .
  
  input:GuyIncognito
    a hello:GreetedIndividual;
    hello:greeting "Hello, Guy Incognito!" .
  
  input:HomerSimpson
    a hello:GreetedIndividual;
    hello:greeting "Hello, Homer Simpson!" .
         </pre>
         
     In this example, the input RDF document contains two input instances
   with the URIs input:GuyIncognito and input:HomerSimpson.  Each input
   instance is processed independently by the service, and so the same
   result could be generated by invoking the service twice with the
   input graphs for Guy Incognito and Homer Simpson separately, and
   afterwords performing an RDF-merge on the two output RDF documents.
   The input instances are identified by the service as those URIs
   having an rdf:type matching the service's _input OWL class_ (hello:
   NamedIndividual).  The purpose of the input OWL class is to describe
   the expected structure of the input instances.  More will be said
   about the purpose and design of the input OWL class in The Input OWL
   Class (Section 9.3.1).

   Analogously to the case for input instances, each output instance in
   the output RDF document is assigned an rdf:type equal to the URI of
   the service's _output OWL class_ (hello:Greetedindividual).  The
   purpose of the _output OWL class_ is to describe the expected
   structure of the output instances generated by the service.
   Comparing the input and output RDF documents, the reader will observe
   that the URI of each output instance is equal to URI of its
   corresponding input instance (input:GuyIncognito and input:
   HomerSimpson, respectively).  This is a general requirement for SADI
   services that ensures that related input and output instances are
   always explicitly linked.  As a result, SADI clients are able to
   merge the input and output RDF documents from a service invocation
   into a single, coherent RDF graph that captures the relationships
   between the input and output data.  For example, a client could load
   the two RDF documents above into a triple store, and then pose
   queries against the triple store such as "What is the greeting for
   Homer Simpson?".
    </section>
    
    <section>
      <h2>Service Metadata</h2>
      
         The metadata for a SADI service provides information that is
   potentially helpful to human and/or software clients attempting to
   use the service.  All provider-specified metadata for a SADI service
   MUST be retrievable as an RDF document by issuing an HTTP GET request
   to the service URL.  Within the RDF document, all metadata items MUST
   be represented as part of a single, connected RDF graph whose root
   URI is the URL of the service.

   The metadata graph MUST include the following items:
<ul>
   <li>input OWL class -- an OWL class describing the expected
      structure of the input RDF graphs consumed by the service</li>

   <li>output OWL class -- an OWL class describing the expected
      structure of the output RDF graphs generated by the service</li>

   If the service has one or more execution parameters, the metadata
   graph MUST also include:

   <li>parameter OWL class -- an OWL class describing execution
      parameters for the service</li>

   <li>default parameter instance -- an instance of the parameter OWL
      class which provides default values for the service execution</li>
</ul>   
   The following items are optional:
<ul>
   <li>service name -- a human readable label for the service</li>

   <li>description -- a human readable description of the service
      functionality</li>

   <li>contact e-mail address -- an e-mail address where the provider
      of the service may be contacted</li>

   <li>service type URI(s) -- one or more rdf:type URIs indicating the
      type of service.  These URIs may be used to categorize the service
      by a wide variety of criteria, such as the task performed, the
      algorithm utilized, or the intended users of the service.</li>

   <li>unit test(s) -- one or more input RDF graph(s) that MUST
      constitute valid input(s) to the service.  The expected output RDF
      graphs corresponding to these input graphs MAY also be provided.</li>

   <li>authoritative flag -- a boolean value that MUST be true if the
      person or organization hosting the service is also the author or
      owner of the data underlying the service, or the author or curator
      of the software which will generate the service output.  If a SADI
      service acts as an interface to third party data or software, the
      value of the authoritative flag MUST be false.  This is to provide
      some Quality-of-Service information in cases where multiple
      services report to provide the same output data.</li>
</ul>
   In addition, any other items deemed useful to clients of the service
   MAY be included in the metadata graph.
   
    </section>
    
    
    <section>
      <h2>Retrieving Service Metadata</h2>
         An RDF document containing the metadata graph MUST be retrievable by
   an HTTP GET request to the service URL.

   The GET request MAY include an Accept header indicating the desired
   RDF serialization format for the response document.  A SADI service
   MUST support content types of text/rdf+n3 for N3 and application/
   rdf+xml for RDF/XML, and MAY support additional content types for
   these formats or for any other RDF serialization formats.  In the
   event of an omitted, unrecognized, or unsupported content type, the
   default content type used for the response MUST be RDF/XML.
      
      
      
    </section>
    
    

    <section>
      <h2>Representing Service Metadata in RDF</h2>
   The schema for the metadata graph is beyond the current scope of the
   SADI specification.

   At the time of writing, all SADI services and SADI-related tools
   known to the authors use the myGrid/Moby service ontology [myGrid/
   Moby] to encode the service metadata graph.  For illustrative
   purposes, the service metadata graph for a parameterized version of
   the "Hello, World!" service
   (http://sadiframework.org/examples/hello-param) is shown below in N3
   format.
      
    <pre class='example highlight'>
      @prefix protege-dc: &lt;http://protege.stanford.edu/plugins/owl/dc/protege-dc.owl#> .
      @prefix mygrid: &lt;http://www.mygrid.org.uk/mygrid-moby-service#> .
      @prefix hello: &lt;http://sadiframework.org/examples/hello.owl#> .
      @prefix test: &lt;http://sadiframework.org/examples/t/> .
      @prefix foaf: &lt;http://xmlns.com/foaf/0.1/> .
      @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#> .

      &lt;http://sadiframework.org/examples/hello-param>
        a mygrid:serviceDescription ;

        #----------------------------------------
        # Service Name
        #----------------------------------------

        mygrid:hasServiceNameText
            "ParamaterizedHelloWorld"^^xsd:string ;

        #----------------------------------------
        # Service Description
        #----------------------------------------

        mygrid:hasServiceDescriptionText
            "A \"Hello, world!\" service where the output language is
            specified in a parameter"^^xsd:string ;

        #----------------------------------------
        # Contact E-mail Address, Authoritative Flag
        #----------------------------------------

        mygrid:providedBy
          [ a mygrid:organisation ;
            protege-dc:creator "person@organization.com"^^xsd:string ;
            mygrid:authoritative "false"^^xsd:boolean
          ] ;
        mygrid:hasOperation
          [ a mygrid:operation ;

            #----------------------------------------
            # Input OWL Class
            #----------------------------------------

            mygrid:inputParameter
                [ a mygrid:parameter ;
                  mygrid:objectType hello:NamedIndividual
                ] ;

            #----------------------------------------
            # Parameter OWL Class, Default Parameter Graph
            #----------------------------------------

            mygrid:inputParameter
                [ a mygrid:secondaryParameter ;
                  mygrid:objectType hello:SecondaryParameters ;
                  mygrid:hasDefaultValue
                    [ a hello:SecondaryParameters ;
                      hello:lang "en"^^xsd:string
                    ]
                ] ;

            #----------------------------------------
            # Output OWL Class
            #----------------------------------------

            mygrid:outputParameter
                [ a mygrid:parameter ;
                  mygrid:objectType hello:GreetedIndividual
                ] ;

            #----------------------------------------
            # Unit Test
            # (test input/output RDF included directly)
            #----------------------------------------

            mygrid:hasUnitTest
                [ a mygrid:testCase ;
                  mygrid:exampleInput
                    [ a hello:InputClass ;
                      foaf:name "Guy Incognito"
                    ] ;
                  mygrid:exampleOutput
                    [ a hello:OutputClass ;
                      hello:greeting "Hello, Guy Incognito!"

                    ]
                ] ;

            #----------------------------------------
            # Unit Test
            # (test input/output RDF in external documents)
            #----------------------------------------

            mygrid:hasUnitTest
                [ a mygrid:testCase ;
                  mygrid:exampleInput test:hello-param-input.rdf ;
                  mygrid:exampleOutput test:hello-param-output.rdf
                ]

          ] .

      
      
    </pre>
      
    </section>
    

    <section>
      <h2>Describing Service Interfaces Using OWL</h2>
         An RDF document containing the metadata graph MUST be retrievable by
   an HTTP GET request to the service URL.

   The GET request MAY include an Accept header indicating the desired
   RDF serialization format for the response document.  A SADI service
   MUST support content types of text/rdf+n3 for N3 and application/
   rdf+xml for RDF/XML, and MAY support additional content types for
   these formats or for any other RDF serialization formats.  In the
   event of an omitted, unrecognized, or unsupported content type, the
   default content type used for the response MUST be RDF/XML.
      
   The input and output OWL classes for a service provide a machine-
   readable representation of the service interface.  This facilitates
   the automation of various data and service matchmaking tasks, such
   as:
   
<ul>
   <li>identifying services that can consume a subset of a given RDF
      graph as input</li>

   <li>extracting input instances for a service from a given RDF graph</li>

   <li>matching the output interface of one service to the input
      interface of another service, in order to create service execution
      chains (workflows)</li>
</ul>
   Moreover, the use of OWL for describing service interfaces enables
   the use an OWL reasoner as the main vehicle for accomplishing these
   tasks.
      
    </section>

    <section>
      <h2>The Input OWL Class</h2>
    The primary purpose of the input OWL class is to identify and extract
   valid input instances for a service from a given RDF data set.  Each
   SADI service has exactly one input OWL class which MUST either be
   referenced by or directly included in the metadata graph for the
   service.

   For illustrative purposes, the following excerpt shows the definition
   for hello:NamedIndividual, which is the input OWL class for the SADI
   "Hello, World!" service:
   
    <pre class='example highlight'>
      
      &lt;owl:Class rdf:ID="NamedIndividual">
        &lt;owl:equivalentClass>
          &lt;owl:Restriction>
            &lt;owl:onProperty rdf:resource="http://xmlns.com/foaf/0.1/name"/>
            &lt;owl:minCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#int">1&lt;/owl:minCardinality>
          &lt;/owl:Restriction>
        &lt;/owl:equivalentClass>
      &lt;/owl:Class>
    </pre>
    
    
     This class definition states that a URI is an instance of hello:
   NamedIndividual if and only if it has one or more values for the
   foaf:name property.  As a result, each input instance for the "Hello,
   World!" service is required to have at least one foaf:name property.

    </section>
    
    
    
    <section>
      <h2> Instance Checking and the Input OWL Class</h2>

         The identification of instances of an OWL class within an RDF graph
   is a commonly supported operation of OWL reasoners, which we we will
   refer to here as _instance checking_.  The purpose of this section is
   provide guidelines for writing an input OWL class that enables an OWL
   reasoner to perform instance checking in a useful manner.

   The most important consideration when authoring an input OWL class is
   that the conditions for class membership should be defined using
   necessary and sufficient ('if and only if') conditions.  In OWL,
   necessary conditions ('if') are defined using the rdfs:subClassOf
   property whereas necessary and sufficient conditions ('if and only
   if') are defined using the owl:equivalentClass property.  For
   example, the following two excerpts show alternate definitions of
   hello:NamedIndividual which use necessary conditions and necessary
   and sufficient conditions, respectively:

      <pre class='example highlight'>
   
&lt;owl:Class rdf:ID="NamedIndividual">
  &lt;rdfs:subClassOf>
    &lt;owl:Restriction>
      &lt;owl:onProperty rdf:resource="http://xmlns.com/foaf/0.1/name"/>
      &lt;owl:minCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#int">1&lt;/owl:minCardinality>
    &lt;/owl:Restriction>
  &lt;/rdfs:subClassOf>
&lt;/owl:Class>


&lt;owl:Class rdf:ID="NamedIndividual">
  &lt;owl:equivalentClass>
    &lt;owl:Restriction>
      &lt;owl:onProperty rdf:resource="http://xmlns.com/foaf/0.1/name"/>
        &lt;owl:minCardinality rdf:datatype="http://www.w3.org/2001/XMLSchema#int">1&lt;/owl:minCardinality>
    &lt;/owl:Restriction>
  &lt;/owl:equivalentClass>
&lt;/owl:Class>

      </pre>


</section>
    
</body>
</html>
